---
import { getCollection } from 'astro:content';
import BaseLayout from '../layouts/BaseLayout.astro';
import PostCard from '../components/PostCard.astro';
import Sidebar from '../components/Sidebar.astro';
import Pagination from '../components/Pagination.astro';

const projects = (await getCollection('projects')).sort(
	(a, b) => new Date(b.data.created).getTime() - new Date(a.data.created).getTime(),
);
const posts = (await getCollection('posts')).sort(
	(a, b) => new Date(b.data.created).getTime() - new Date(a.data.created).getTime(),
);
const retrospectives = (await getCollection('retrospectives')).sort(
	(a, b) => new Date(b.data.created).getTime() - new Date(a.data.created).getTime(),
);

const pageSize = 20;

const labelFromFolder = (slug: string) => slug.replace(/-/g, ' ');

const getPostCategory = (entry: (typeof posts)[number]) => {
	const id = (entry as any).id || '';
	const cat = id.split('/')[0] || 'misc';
	return cat;
};

const getRetroCategory = (entry: (typeof retrospectives)[number]) => {
	const id = (entry as any).id || '';
	return id.split('/')[0] || 'retrospectives';
};

const postCategories = posts.reduce<Record<string, { count: number; label: string }>>((acc, p) => {
	const cat = getPostCategory(p);
	if (!acc[cat]) acc[cat] = { count: 0, label: labelFromFolder(cat) };
	acc[cat].count += 1;
	return acc;
}, {});

const getProjectCategory = (entry: (typeof projects)[number]) => {
	const id = (entry as any).id || '';
	return id.split('/')[0] || 'project-showcase';
};

const projectCategories = projects.reduce<Record<string, { count: number; label: string }>>((acc, p) => {
	const cat = getProjectCategory(p);
	if (!acc[cat]) acc[cat] = { count: 0, label: labelFromFolder(cat) };
	acc[cat].count += 1;
	return acc;
}, {});

const projectTree = Object.entries(projectCategories).map(([key, info]) => ({
	folder: info.label,
	title: info.label,
	slug: key,
	count: info.count,
}));

const postTree = Object.entries(postCategories).map(([key, info]) => ({
	folder: info.label,
	title: info.label,
	slug: key,
	count: info.count,
}));

const retroCategories = retrospectives.reduce<Record<string, { count: number; label: string }>>((acc, r) => {
	const cat = getRetroCategory(r);
	if (!acc[cat]) acc[cat] = { count: 0, label: labelFromFolder(cat) };
	acc[cat].count += 1;
	return acc;
}, {});

const retroTree = Object.entries(retroCategories).map(([key, info]) => ({
	folder: info.label,
	title: info.label,
	slug: key,
	count: info.count,
}));

const combined = [
	...projects.map((p) => ({ type: 'project', entry: p, category: getProjectCategory(p) })),
	...posts.map((p) => ({ type: 'post', entry: p, category: getPostCategory(p) })),
	...retrospectives.map((r) => ({ type: 'retro', entry: r, category: getRetroCategory(r) })),
].sort((a, b) => new Date(b.entry.data.created).getTime() - new Date(a.entry.data.created).getTime());

const pageCount = Math.max(1, Math.ceil(combined.length / pageSize));
---

<BaseLayout title="홈">
	<div class="layout-grid">
		<Sidebar />

		<div class="main-column">
			<section class="hero">
				<div>
					<p class="eyebrow">Fullstack Developer · CTO @ Portzone</p>
					<h1>김민석 · 포트폴리오 & 기술 블로그</h1>
					<p class="lede">
						“문제를 정확히 정의하고, 작동하는 것을 빠르게 만들고, 마지막 20%에서 품질을 지켜내는 것”을
						가장 중요하게 생각합니다. 기획-프론트-백엔드-데이터-클라우드까지 전 스택을 일관된
						아키텍처로 엮어 제품을 출시해 왔습니다.
					</p>
					<ul class="lede" style="list-style: disc; padding-left: 18px; margin: 10px 0 12px;">
						<li>집중 분야: AI 추천·강화학습, 모던 풀스택(Next.js/NestJS), Web3 연동</li>
						<li>역할: 포트존 CTO, 서강대 데이터사이언스·AI 전공</li>
						<li>원칙: 보안·자동화·가시성으로 서비스 품질을 높이는 설계</li>
					</ul>
					<div class="lede" style="margin: 10px 0 14px;">
						<p style="margin: 4px 0;"><strong>AI/데이터:</strong> 추천·랭킹 모델, 강화학습 실험, OCR+LLM 파이프라인</p>
						<p style="margin: 4px 0;"><strong>FE/모바일:</strong> Next.js App Router, React Native/Expo, 성능·DX 최적화</p>
						<p style="margin: 4px 0;"><strong>BE/인프라:</strong> NestJS/GraphQL/Prisma, Supabase/Firebase, AWS/GCP, CI/CD 자동화</p>
						<p style="margin: 4px 0;"><strong>보안·신뢰성:</strong> AWS KMS·Web Crypto 이중 암호화, 다단계 인증/권한 분리, 장애 자동 복구</p>
						<p style="margin: 4px 0;"><strong>성과 지표:</strong> 배포 리드타임 50% 단축, 장애 대응 시간 50% 단축, 디자인 시스템 온보딩 70% 절감</p>
						<p style="margin: 4px 0;"><strong>운영 문화:</strong> GitHub Actions + pnpm 모노레포, HeadVer·Husky, ESLint/Prettier로 품질 게이트 일원화</p>
					</div>
					<div class="actions">
						<a class="button primary" href="mailto:kochevnik99@gmail.com">이메일</a>
						<a class="button ghost" href="https://linkedin.com/in/kmsk99" target="_blank">LinkedIn</a>
					</div>
				</div>
			</section>

			<section class="block">
				<header class="block__header">
					<div>
						<p class="eyebrow">Feed</p>
						<h2>최근 글</h2>
					</div>
					<p class="lede">프로젝트와 포스트를 한 리스트로 모았습니다.</p>
				</header>
				<div class="list filter-target">
					{combined.map((item, idx) => {
						const page = Math.floor(idx / pageSize) + 1;
						const tags = item.entry.data.tags?.join(',') ?? '';
						return (
							<div
								class="list-row"
								data-type={item.type}
								data-category={item.category}
								data-tags={tags}
								data-page={page}
							>
								<PostCard entry={item.entry as any} category={item.category} />
							</div>
						);
					})}
				</div>
				<Pagination pageCount={pageCount} />
			</section>
		</div>
	</div>

	<script is:inline>
		const initFilters = () => {
			const tagButtons = Array.from(document.querySelectorAll('.tag-pill'));
			const targets = Array.from(document.querySelectorAll('.filter-target > *'));
			const categoryButtons = Array.from(document.querySelectorAll('.tree__btn'));
			const paginationContainer = document.querySelector('.pagination');
			const paginationButtons = Array.from(document.querySelectorAll('.pagination-btn'));
			const pageNumberButtons = paginationButtons.filter(
				(btn) => btn.dataset.page && btn.dataset.page !== 'prev' && btn.dataset.page !== 'next',
			);
			const pageSize = 20;
			const initialTotalPages = Math.max(
				1,
				Math.ceil(targets.length / pageSize),
			); /* 서버 렌더된 pageCount 대체 */

			let currentTag = '__all';
			let currentCategory = '__all';
			let currentType = 'all';
			let currentPage = 1;
			let totalPages = initialTotalPages;

			// URL 파라미터로 초기 필터 적용 (사이드바 네비게이션 연동)
			const params = new URLSearchParams(window.location.search);
			const urlCategory = params.get('category');
			const urlType = params.get('type');
			if (urlCategory) currentCategory = urlCategory;
			if (urlType) currentType = urlType;

			function applyFilters() {
				const matched = [];
				targets.forEach((el) => {
					const elType = el.dataset.type;
					const elCategory = el.dataset.category;
					const elTags = el.dataset.tags?.split(',').filter(Boolean) ?? [];

					const matchType = currentType === 'all' || elType === currentType;
					const matchCategory = currentCategory === '__all' || elCategory === currentCategory;
					const matchTag = currentTag === '__all' || elTags.includes(currentTag);
					if (matchType && matchCategory && matchTag) {
						matched.push(el);
					} else {
						el.style.display = 'none';
					}
				});

				totalPages = Math.max(1, Math.ceil(matched.length / pageSize));
				if (currentPage > totalPages) currentPage = totalPages;

				matched.forEach((el, idx) => {
					const page = Math.floor(idx / pageSize) + 1;
					el.style.display = page === currentPage ? '' : 'none';
				});

				const show = totalPages > 1;
				if (paginationContainer) paginationContainer.style.display = show ? '' : 'none';

				pageNumberButtons.forEach((btn) => {
					const page = Number(btn.dataset.page || '1');
					btn.style.display = page <= totalPages ? '' : 'none';
					btn.classList.toggle('active', page === currentPage);
				});
			}

			function setPage(newPage) {
				if (newPage < 1) newPage = 1;
				if (newPage > totalPages) newPage = totalPages;
				currentPage = newPage;
				applyFilters();
			}

			tagButtons.forEach((btn) => {
				btn.addEventListener('click', () => {
					tagButtons.forEach((b) => b.classList.remove('active'));
					btn.classList.add('active');
					currentTag = btn.dataset.tag;
					setPage(1);
				});
			});

			categoryButtons.forEach((btn) => {
				btn.addEventListener('click', () => {
					categoryButtons.forEach((b) => b.classList.remove('active'));
					btn.classList.add('active');
					currentType = btn.dataset.type;
					currentCategory = btn.dataset.category;
					setPage(1);
				});
			});

			paginationButtons.forEach((btn) => {
				btn.addEventListener('click', () => {
					const val = btn.dataset.page;
					if (val === 'prev') {
						setPage(currentPage - 1);
						return;
					}
					if (val === 'next') {
						setPage(currentPage + 1);
						return;
					}
					setPage(Number(val || '1'));
				});
			});

			setPage(1);
		};

		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initFilters, { once: true });
		} else {
			initFilters();
		}
	</script>
</BaseLayout>

